// Generated by CoffeeScript 1.3.3
(function() {

  fixtures.simpleview = "<div id=\"simpleView\" data-model=\"app.model.person\">\n	<h2 id=\"title\" data-bind=\"${firstName} ${lastName}\"></h2>\n	<table id=\"personTable\">\n		<tr>\n			<th>Phone #:</th>\n			<td data-bind=\"${phone}\"></td>\n		</tr>\n		<tr>\n			<th>Address:</th>\n			<td id=\"addressCell\" data-model=\"app.model.person.address\">\n				<span id=\"street\" data-bind=\"${street},\"></span><br/>\n				<span id=\"cityAndCountry\" data-bind=\"${city}, ${country},\"></span><br/>\n				<span id=\"zip\" data-bind=\"${zip}\"></span>\n			</td>\n		</tr>\n		<tr>\n			<th>Email:</th>\n			<td data-bind=\"${email}\"></td>\n		</tr>\n	</table>\n\n	<table id=\"friendsTable\">\n		<theader>\n			<tr>\n				<th>ID</th>\n				<th>Name</th>\n				<th>Email</th>\n			</tr>\n		</theader>\n		<tbody data-list=\"friends\">\n			<tr>\n				<td data-bind=\"${id}></td>\n				<td data-bind=\"${name}></td>\n				<td data-bind=\"${email}></td>\n			</tr>\n		</tbody>\n		<tfoot>\n			<tr>\n				<td colspan=\"3\" data-bind=\"friends.size\"></td>\n			</tr>\n		</tfoot>\n	</table>\n</div>";

  /*
  to be added in future versions:
  
  collection.indexOn('id', 'name')
  collection.searchFor('something')
  
  collection.extract('id').join(',');
  collection.extract('id', 'name');
  */


  describe('collection', function() {
    var collection, source;
    collection = null;
    source = null;
    beforeEach(function() {
      source = [];
      source.push({
        name: 'John Doe',
        email: 'john@example.com'
      });
      source.push({
        name: 'Jane Doe',
        email: 'jane@example.com'
      });
      return collection = lean.collection(source);
    });
    it('should construct a Collection object with the correct properties and methods', function() {
      expect(collection.source).toBe(source);
      expect(collection.size()).toBe(2);
      return expect(collection.changed).toBeDefined();
    });
    it('should add an item and be able to retrieve it using the get function', function() {
      var item;
      collection.add({
        name: 'test',
        email: 'test@example.com'
      });
      item = collection.get(2);
      expect(collection.size()).toBe(3);
      expect(item.name).toBe('test');
      return expect(item.email).toBe('test@example.com');
    });
    it('should remove an existing item in the collection using the remove function', function() {
      var item;
      item = collection.remove(0);
      expect(collection.size()).toBe(1);
      expect(item.name).toBe('John Doe');
      return expect(item.email).toBe('john@example.com');
    });
    it('should return null when remove is called with an out of bounds index', function() {
      var item;
      item = collection.remove(100);
      return expect(item).toBe(void 0);
    });
    it('should replace an existing item at the specified index', function() {
      var item;
      collection.replace(1, {
        name: 'replaced',
        email: 'replaced@example.com'
      });
      item = collection.get(1);
      expect(item.name).toBe('replaced');
      return expect(item.email).toBe('replaced@example.com');
    });
    it('should throw an index out of bounds error when trying to replace an index that is not in the source array', function() {
      var tester;
      tester = function() {
        return collection.replace(100, {});
      };
      return expect(tester).toThrow();
    });
    it('should dispatch the changed signal with the add action when an item is added', function() {
      collection.changed.addOnce(function(info) {
        expect(info.action).toBe('add');
        expect(info.item.name).toBe('test');
        expect(info.item.email).toBe('test@test.com');
        return expect(info.index).toBe(3);
      });
      return collection.add({
        name: 'test',
        email: 'test@test.com'
      });
    });
    it('should dispatch the changed signal with the remove action when an item is removed', function() {
      collection.changed.addOnce(function(info) {
        expect(info.action).toBe('remove');
        expect(info.item.name).toBe('John Doe');
        expect(info.item.email).toBe('john@example.com');
        return expect(info.index).toBe(0);
      });
      return collection.remove(0);
    });
    return it('should dispatch the changed signal with the replace action when an item is replaced', function() {
      collection.changed.addOnce(function(info) {
        expect(info.action).toBe('replace');
        expect(info.item.name).toBe('replaced');
        expect(info.item.email).toBe('replaced@example.com');
        return expect(info.index).toBe(1);
      });
      return collection.replace(1, {
        name: 'replaced',
        email: 'replaced@example.com'
      });
    });
  });

  describe('defaults', function() {
    return it('should have defaults set initially, be able to change them and restore them', function() {
      var assert;
      assert = function(value) {
        return expect(lean.defaults.bindable).toBe(value);
      };
      assert(true);
      lean.defaults.bindable = false;
      assert(false);
      lean.defaults.restore();
      return assert(true);
    });
  });

  describe('helper', function() {
    var dom, helper;
    dom = null;
    helper = null;
    beforeEach(function() {
      dom = fixture(fixtures.simpleview);
      window.app = {
        model: {
          person: lean.model({
            id: 1234,
            firstName: 'Derek',
            lastName: 'Santos',
            phone: '555-555-5555',
            email: 'test@leanjs.org',
            address: lean.model({
              street: '123 fake street',
              city: 'Toronto',
              country: 'Canada',
              zip: 12345
            })
          })
        }
      };
      return helper = lean.helper('simpleView', dom);
    });
    afterEach(function() {
      return delete window['app'];
    });
    it('should initialize a helper object with nested element references named by id.', function() {
      expect(helper.title.element.nodeName).toBe('H2');
      expect(helper.personTable.element.nodeName).toBe('TABLE');
      expect(helper.personTable.addressCell.street.element.nodeName).toBe('SPAN');
      expect(helper.personTable.addressCell.cityAndCountry.element.nodeName).toBe('SPAN');
      return expect(helper.personTable.addressCell.zip.element.nodeName).toBe('SPAN');
    });
    it('should set model objects on helper and nested helpers', function() {
      var addressCell, model, person;
      person = app.model.person;
      expect(helper.model.id).toBe(person.id);
      addressCell = helper.personTable.addressCell;
      model = addressCell.model;
      expect(model.street).toBe(person.address.street);
      expect(addressCell.street.model.street).toBe(person.address.street);
      expect(addressCell.cityAndCountry.model.city).toBe(person.address.city);
      expect(addressCell.cityAndCountry.model.country).toBe(person.address.country);
      return expect(addressCell.zip.model.zip).toBe(person.address.zip);
    });
    return it('should initiaize bindings for helper', function() {
      var address, person, verify;
      person = app.model.person;
      address = person.address;
      verify = function() {
        var addressCell, html;
        expect(helper.title.element.innerText).toBe("" + person.firstName + " " + person.lastName);
        html = helper.personTable.element.innerHTML;
        expect(html).toMatch(person.phone);
        expect(html).toMatch(person.email);
        addressCell = helper.personTable.addressCell;
        expect(addressCell.street.element.innerText).toBe("" + address.street + ",");
        expect(addressCell.cityAndCountry.element.innerText).toBe("" + address.city + ", " + address.country + ",");
        return expect(addressCell.zip.element.innerText).toBe("" + address.zip);
      };
      verify();
      person.set({
        phone: '555-111-2222',
        email: 'fake@leanjs.org'
      });
      person.address.set({
        street: '987 not fake street',
        city: 'Miami',
        country: 'USA',
        zip: 9876
      });
      return verify();
    });
  });

  describe('model', function() {
    var expectation, model;
    model = null;
    expectation = {
      title: 'LeanJS',
      body: 'A simple light framework.'
    };
    beforeEach(function() {
      return model = lean.model(expectation);
    });
    afterEach(function() {
      return model = null;
    });
    it('should initialize properties', function() {
      var key, value, _results;
      _results = [];
      for (key in expectation) {
        value = expectation[key];
        _results.push(expect(model[key]).toBe(value));
      }
      return _results;
    });
    it('should dispatch changed signal when a property changes', function() {
      var newTitle;
      newTitle = 'Changed Title';
      spyOn(model.changed, 'dispatch');
      model.set('title', newTitle);
      return expect(model.changed.dispatch).toHaveBeenCalledWith('title', newTitle, 'LeanJS');
    });
    it('should automatically update a property of destination object with a value from a model object', function() {
      var destination;
      destination = {
        output: ''
      };
      model.bind('title').to(destination, 'output');
      expect(destination.output).toBe('LeanJS');
      model.set('title', 'Binding');
      return expect(destination.output).toBe('Binding');
    });
    it('should call a specified function when a property has changed using watch()', function() {
      var watcher;
      watcher = function(newValue, oldValue) {
        expect(newValue).toBe('new value');
        expect(oldValue).toBe('LeanJS');
        return expect(model.title).toBe('new value');
      };
      model.watch('title', watcher);
      return model.set('title', 'new value');
    });
    return it('should update multiple properties and dispatch changed signal for each', function() {
      spyOn(model.changed, 'dispatch');
      model.set({
        title: 'Title2',
        body: 'Body2'
      });
      expect(model.changed.dispatch).toHaveBeenCalledWith('title', 'Title2', 'LeanJS');
      expect(model.changed.dispatch).toHaveBeenCalledWith('body', 'Body2', 'A simple light framework.');
      expect(model.title).toBe('Title2');
      return expect(model.body).toBe('Body2');
    });
  });

  describe('util', function() {
    beforeEach(function() {
      return window.app = {
        model: {
          test: {
            prop1: 'value1',
            prop2: 'value2'
          }
        }
      };
    });
    afterEach(function() {
      return delete window['app'];
    });
    it('should return true when a node object is of type 1 (an element node) and false otherwise', function() {
      var node;
      node = {
        nodeType: 1
      };
      expect(lean.util.isElementNode(node)).toBe(true);
      node = {
        nodeType: 2
      };
      return expect(lean.util.isElementNode(node)).toBe(false);
    });
    it('should return an object from the global scope from the specified path using dot notation', function() {
      var obj;
      obj = lean.util.getObject('app.model.test');
      expect(obj.prop1).toBe('value1');
      return expect(obj.prop2).toBe('value2');
    });
    return it('should return an object from a specified object using dot notation', function() {
      var result, root;
      root = {
        garage: {
          car: {
            parts: ['engine', 'door']
          }
        }
      };
      result = lean.util.getObject('garage.car.parts', root);
      return expect(result.length).toBe(2);
    });
  });

}).call(this);
